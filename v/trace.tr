# Initial reset (active high) - 2 cycles
0000_1_0_0000_0_0_00000000000000000000000000000000
0000_1_0_0000_0_0_00000000000000000000000000000000

# Release reset
0000_0_0_0000_0_0_00000000000000000000000000000000

# Wait for module to stabilize
0000_0_0_0000_0_0_00000000000000000000000000000000
0000_0_0_0000_0_0_00000000000000000000000000000000

# Begin JPEG data stream - SOI marker (0xFFD8)
# First byte of SOI marker (0xFF)
0001_0_1_1111_0_0_00000000000000000000000011111111
# Second byte of SOI marker (0xD8)
0001_0_1_1111_0_0_00000000000000000000000011011000

# APP0 marker (0xFFE0)
0001_0_1_1111_0_0_00000000000000000000000011111111
0001_0_1_1111_0_0_00000000000000000000000011100000

# Length of APP0 segment (16 bytes in big-endian):
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000010000

# "JFIF" identifier (ASCII)
0001_0_1_1111_0_0_00000000000000000000000001001010
0001_0_1_1111_0_0_00000000000000000000000001000110
0001_0_1_1111_0_0_00000000000000000000000001001001
0001_0_1_1111_0_0_00000000000000000000000001000110

# JFIF version (1.1)
0001_0_1_1111_0_0_00000000000000000000000000000001
0001_0_1_1111_0_0_00000000000000000000000000000001

# Density units (0), X density (1), Y density (1)
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000000001
0001_0_1_1111_0_0_00000000000000000000000000000001

# Thumbnail (0x0)
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000000000

# Start of Frame (SOF0) marker (0xFFC0)
0001_0_1_1111_0_0_00000000000000000000000011111111
0001_0_1_1111_0_0_00000000000000000000000011000000

# SOF0 length (17 bytes): 0x0011
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000010001

# Precision (8 bits)
0001_0_1_1111_0_0_00000000000000000000000000001000

# Image height (16 pixels): 0x0010
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000010000

# Image width (16 pixels): 0x0010
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000010000

# Number of components (3)
0001_0_1_1111_0_0_00000000000000000000000000000011

# Component ID 1 (Y), sampling factors (1x1), QT 0
0001_0_1_1111_0_0_00000000000000000000000000000001
0001_0_1_1111_0_0_00000000000000000000000000010001
0001_0_1_1111_0_0_00000000000000000000000000000000

# Component ID 2 (Cb), sampling factors (1x1), QT 1
0001_0_1_1111_0_0_00000000000000000000000000000010
0001_0_1_1111_0_0_00000000000000000000000000010001
0001_0_1_1111_0_0_00000000000000000000000000000001

# Component ID 3 (Cr), sampling factors (1x1), QT 1
0001_0_1_1111_0_0_00000000000000000000000000000011
0001_0_1_1111_0_0_00000000000000000000000000010001
0001_0_1_1111_0_0_00000000000000000000000000000001

# Define Quantization Table (DQT) marker (0xFFDB)
0001_0_1_1111_0_0_00000000000000000000000011111111
0001_0_1_1111_0_0_00000000000000000000000011011011

# DQT length (67 bytes): 0x0043
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000001000011

# QT0 precision (0) and ID (0): 0x00
0001_0_1_1111_0_0_00000000000000000000000000000000

# QT0 values (8x8 table) - showing first 8 as example
0001_0_1_1111_0_0_00000000000000000000000000010000
0001_0_1_1111_0_0_00000000000000000000000000001011
0001_0_1_1111_0_0_00000000000000000000000000001100
0001_0_1_1111_0_0_00000000000000000000000000010000
0001_0_1_1111_0_0_00000000000000000000000000010100
0001_0_1_1111_0_0_00000000000000000000000000011001
0001_0_1_1111_0_0_00000000000000000000000000011010
0001_0_1_1111_0_0_00000000000000000000000000010100

# (Would continue with remaining 56 QT values...)

# Define Huffman Table (DHT) marker (0xFFC4)
0001_0_1_1111_0_0_00000000000000000000000011111111
0001_0_1_1111_0_0_00000000000000000000000011000100

# DHT length and table info would follow...
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000011110

# DHT values (would include numerous bytes)
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000000001
0001_0_1_1111_0_0_00000000000000000000000000000101
0001_0_1_1111_0_0_00000000000000000000000000000001
# (Would continue with more DHT data...)

# Start of Scan (SOS) marker (0xFFDA)
0001_0_1_1111_0_0_00000000000000000000000011111111
0001_0_1_1111_0_0_00000000000000000000000011011010

# SOS length (12 bytes): 0x000C
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000001100

# Number of components in scan (3)
0001_0_1_1111_0_0_00000000000000000000000000000011

# Component 1 (Y) uses DC/AC Huffman table 0
0001_0_1_1111_0_0_00000000000000000000000000000001
0001_0_1_1111_0_0_00000000000000000000000000000000

# Component 2 (Cb) uses DC/AC Huffman table 1
0001_0_1_1111_0_0_00000000000000000000000000000010
0001_0_1_1111_0_0_00000000000000000000000000010001

# Component 3 (Cr) uses DC/AC Huffman table 1
0001_0_1_1111_0_0_00000000000000000000000000000011
0001_0_1_1111_0_0_00000000000000000000000000010001

# Spectral selection (start 0, end 63)
0001_0_1_1111_0_0_00000000000000000000000000000000
0001_0_1_1111_0_0_00000000000000000000000000111111

# Successive approximation (0)
0001_0_1_1111_0_0_00000000000000000000000000000000

# Entropy-coded data (simplified example - actual data would be much more)
0001_0_1_1111_0_0_00000000000000000000000010110111
0001_0_1_1111_0_0_00000000000000000000000001001010
0001_0_1_1111_0_0_00000000000000000000000011101001
0001_0_1_1111_0_0_00000000000000000000000000111011

# Last block of entropy-coded data with last flag set
0001_0_1_1111_1_0_00000000000000000000000010110010
0001_0_1_1111_1_0_00000000000000000000000011101100

# End of Image (EOI) marker (0xFFD9)
0001_0_1_1111_0_0_00000000000000000000000011111111
0001_0_1_1111_0_0_00000000000000000000000011011001

# Now receive output pixels - enable outport_accept
# Wait and check for valid output pixels
0010_0_0_0000_0_1_00000000000000000000000000000000
0010_0_0_0000_0_1_00000000000000000000000000000000

# Continue receiving pixels - below checks for a specific pixel:
# For each pixel we'd check:
# - outport_valid = 1 (expected)
# - pixel position (x=0, y=0 in this example)
# - pixel values (r=128, g=128, b=128 in this example)
0010_0_0_0000_0_1_10000000000000000000000010000000

# We wait for more pixels with different coordinate values
0010_0_0_0000_0_1_10000000100000000000000010000000
0010_0_0_0000_0_1_10000001000000000000000010000000
# (... many more pixel checks would follow ...)

# Wait for idle signal
0000_0_0_0000_0_0_00000000000000000000000000000000
0000_0_0_0000_0_0_00000000000000000000000000000000

# End simulation
0100_0_0_0000_0_0_00000000000000000000000000000000